# Порівняння Жадібного Алгоритму та Динамічного Програмування для Завдання про Розподіл Монет

## Опис

У цьому проекті ми реалізували дві функції для видачі решти покупцеві: жадібний алгоритм (`find_coins_greedy`) та алгоритм динамічного програмування (`find_min_coins`). Обидва підходи мають на меті видати решту із найменшою кількістю монет, але використовують різні стратегії.

### Завдання

1. **Жадібний алгоритм**: використовує монети найбільшого номіналу, які доступні, і додає їх до результату, поки сума не буде вичерпана.
2. **Динамічне програмування**: забезпечує мінімальну кількість монет для досягнення суми, будуючи таблицю результатів для всіх проміжних сум.

### Приклади виконання

Для суми 113:

- **Жадібний алгоритм**: `{50: 2, 10: 1, 2: 1, 1: 1}`
- **Динамічне програмування**: `{1: 1, 2: 1, 10: 1, 50: 2}`

### Аналіз ефективності

#### Часова Складність

- **Жадібний алгоритм**: O(n), де `n` — кількість номіналів монет. Оскільки він завжди обирає найбільшу доступну монету, кількість ітерацій невелика.
- **Динамічне програмування**: O(amount \* n), де `amount` — сума, яку потрібно видати, і `n` — кількість номіналів монет. Алгоритм виконує більше ітерацій, але забезпечує оптимальне рішення для будь-якого набору монет.

#### Продуктивність при великих сумах

Жадібний алгоритм є швидшим і підходить для великих сум, але тільки за умови, що доступні номінали монет є "оптимальними" для суми, як у випадку зі стандартними монетами. Якщо ж набір монет не має конкретної структури, жадібний алгоритм може дати не найефективніше рішення.

Динамічний алгоритм гарантує оптимальне розв'язання для будь-якого набору монет, але при цьому потребує більше часу для обчислення, що може впливати на продуктивність при великих сумах.

#### Висновок

- **Жадібний алгоритм** є швидким і підходить для стандартних наборів монет, де використання найбільших номіналів забезпечує мінімальну кількість монет.
- **Динамічне програмування** забезпечує точність та оптимальність, але є менш продуктивним при великих сумах, оскільки потребує більше часу для розрахунку.

Отже, вибір між жадібним алгоритмом і динамічним програмуванням залежить від контексту використання та набору монет. Якщо ми маємо стандартний набір монет, жадібний алгоритм може бути кращим вибором для швидкості. В інших випадках, особливо зі складними наборами монет, динамічне програмування є надійнішим підходом.
